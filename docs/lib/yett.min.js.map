{"version":3,"file":"yett.min.js","sources":["../../src/checks.js","../../src/variables.js","../../src/observer.js","../../src/monkey.js","../../src/unblock.js"],"sourcesContent":["import { patterns, TYPE_ATTRIBUTE } from './variables'\n\nexport const isOnBlacklist = (src, type) => (\n    src &&\n    (!type || type !== TYPE_ATTRIBUTE) &&\n    (\n        (!patterns.blacklist || patterns.blacklist.some(pattern => pattern.test(src))) &&\n        (!patterns.whitelist || patterns.whitelist.every(pattern => !pattern.test(src)))\n    )\n)\n\nexport const willBeUnblocked = function(script) {\n    const src = script.getAttribute('src')\n    return (\n        patterns.blacklist && patterns.blacklist.every(entry => !entry.test(src)) ||\n        patterns.whitelist && patterns.whitelist.some(entry => entry.test(src))\n    )\n}","export const TYPE_ATTRIBUTE = 'javascript/blocked'\n\nexport const patterns = {\n    blacklist: window.YETT_BLACKLIST,\n    whitelist: window.YETT_WHITELIST\n}\n\n// Backup list containing the original blacklisted script elements\nexport const backupScripts = {\n    blacklisted: []\n}\n\nexport const features = {\n    iframe: window.YETT_IFRAME\n}\n\n// Backup list containing the original blacklisted iframe elements\nexport const backupIframes = {\n    blacklisted: []\n}","import { backupScripts, backupIframes, TYPE_ATTRIBUTE, features } from './variables'\nimport { isOnBlacklist } from './checks'\n\n// Setup a mutation observer to track DOM insertion\nexport const observer = new MutationObserver(mutations => {\n    console.log(backupIframes);\n    for (let i = 0; i < mutations.length; i++) {\n        const { addedNodes } = mutations[i];\n        for(let i = 0; i < addedNodes.length; i++) {\n            const node = addedNodes[i]\n            // For each added script tag\n            if(node.nodeType === 1 && node.tagName === 'SCRIPT') {\n                const src = node.src\n                const type = node.type\n                // If the src is inside the blacklist and is not inside the whitelist\n                if(isOnBlacklist(src, type)) {\n                    // We backup the node\n                    backupScripts.blacklisted.push([node, node.type])\n\n                    // Blocks inline script execution in Safari & Chrome\n                    node.type = TYPE_ATTRIBUTE\n\n                    // Firefox has this additional event which prevents scripts from beeing executed\n                    const beforeScriptExecuteListener = function (event) {\n                        // Prevent only marked scripts from executing\n                        if(node.getAttribute('type') === TYPE_ATTRIBUTE)\n                            event.preventDefault()\n                        node.removeEventListener('beforescriptexecute', beforeScriptExecuteListener)\n                    }\n                    node.addEventListener('beforescriptexecute', beforeScriptExecuteListener)\n\n                    // Remove the node from the DOM\n                    node.parentElement && node.parentElement.removeChild(node)\n                }\n            }\n            if(node.nodeType === 1 && node.tagName === 'IFRAME' && features.iframe !== false) {\n                const src = node.src;\n                \n                // Controllo che l'src del mio nodo iFrame sia nella blacklist\n                if(isOnBlacklist(src)) {\n                    let id = `yett_iframe_id_${Math.floor(Math.random() * 1000) + 1}`;\n                    \n                    // Faccio un backup del nodo\n                    backupIframes.blacklisted.push([id, node]);\n\n                    // Rimuovo il nodo\n                    let newPlaceholder = document.createElement('span');\n                    newPlaceholder.setAttribute('data-yett-id', id);\n                    node.parentElement.insertBefore(newPlaceholder, node)\n                    node.parentElement && node.parentElement.removeChild(node)\n                }\n            }\n        }\n    }\n})\n\n// Starts the monitoring\nobserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true\n})","import { TYPE_ATTRIBUTE } from './variables'\nimport { isOnBlacklist } from './checks'\n\nconst createElementBackup = document.createElement\n\nconst originalDescriptors = {\n    src: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src'),\n    type: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'type')\n}\n\n// Monkey patch the createElement method to prevent dynamic scripts from executing\ndocument.createElement = function(...args) {\n    // If this is not a script tag, bypass\n    if(args[0].toLowerCase() !== 'script')\n        return createElementBackup.bind(document)(...args)\n\n    const scriptElt = createElementBackup.bind(document)(...args)\n\n    // Define getters / setters to ensure that the script type is properly set\n    try {\n        Object.defineProperties(scriptElt, {\n            'src': {\n                get() {\n                    return originalDescriptors.src.get.call(this)\n                },\n                set(value) {\n                    if(isOnBlacklist(value, scriptElt.type)) {\n                        originalDescriptors.type.set.call(this, TYPE_ATTRIBUTE)\n                    }\n                    originalDescriptors.src.set.call(this, value)\n                }\n            },\n            'type': {\n                set(value) {\n                    const typeValue = isOnBlacklist(scriptElt.src, scriptElt.type) ? TYPE_ATTRIBUTE : value\n                    originalDescriptors.type.set.call(this, typeValue)\n                }\n            }\n        })\n\n        // Monkey patch the setAttribute function so that the setter is called instead\n        scriptElt.setAttribute = function(name, value) {\n            if(name === 'type' || name === 'src')\n                scriptElt[name] = value\n            else\n                HTMLScriptElement.prototype.setAttribute.call(scriptElt, name, value)\n        }\n    } catch (error) {\n        // eslint-disable-next-line\n        console.warn(\n            'Yett: unable to prevent script execution for script src ', scriptElt.src, '.\\n',\n            'A likely cause would be because you are using a third-party browser extension that monkey patches the \"document.createElement\" function.'\n        )\n    }\n    return scriptElt\n}","import {\n    patterns,\n    backupScripts,\n    backupIframes,\n    TYPE_ATTRIBUTE\n} from './variables'\n\nimport {\n    willBeUnblocked\n} from './checks'\n\nimport {\n    observer\n} from './observer'\n\nconst URL_REPLACER_REGEXP = new RegExp('[|\\\\{}()[\\\\]^$+*?.]', 'g')\n\n// Unblocks all (or a selection of) blacklisted scripts.\nexport const unblock = function(...scriptUrlsOrRegexes) {\n    if(scriptUrlsOrRegexes.length < 1) {\n        patterns.blacklist = []\n        patterns.whitelist = []\n    } else {\n        if(patterns.blacklist) {\n            patterns.blacklist = patterns.blacklist.filter(pattern => (\n                scriptUrlsOrRegexes.every(urlOrRegexp => {\n                    if(typeof urlOrRegexp === 'string')\n                        return !pattern.test(urlOrRegexp)\n                    else if(urlOrRegexp instanceof RegExp)\n                        return pattern.toString() !== urlOrRegexp.toString()\n                })\n            ))\n        }\n        if(patterns.whitelist) {\n            patterns.whitelist = [\n                ...patterns.whitelist,\n                ...scriptUrlsOrRegexes\n                    .map(urlOrRegexp => {\n                        if(typeof urlOrRegexp === 'string') {\n                            const escapedUrl = urlOrRegexp.replace(URL_REPLACER_REGEXP, '\\\\$&')\n                            const permissiveRegexp = '.*' + escapedUrl + '.*'\n                            if(patterns.whitelist.every(p => p.toString() !== permissiveRegexp.toString())) {\n                                return new RegExp(permissiveRegexp)\n                            }\n                        } else if(urlOrRegexp instanceof RegExp) {\n                            if(patterns.whitelist.every(p => p.toString() !== urlOrRegexp.toString())) {\n                                return urlOrRegexp\n                            }\n                        }\n                        return null\n                    })\n                    .filter(Boolean)\n            ]\n        }\n    }\n\n\n    // Parse existing script tags with a marked type\n    const tags = document.querySelectorAll(`script[type=\"${TYPE_ATTRIBUTE}\"]`)\n    for(let i = 0; i < tags.length; i++) {\n        const script = tags[i]\n        if(willBeUnblocked(script)) {\n            backupScripts.blacklisted.push([script, 'application/javascript'])\n            script.parentElement.removeChild(script)\n        }\n    }\n\n    // Exclude 'whitelisted' scripts from the blacklist and append them to <head>\n    let indexOffset = 0;\n    [...backupScripts.blacklisted].forEach(([script, type], index) => {\n        if(willBeUnblocked(script)) {\n            const scriptNode = document.createElement('script')\n            scriptNode.setAttribute('src', script.src)\n            scriptNode.setAttribute('type', type || 'application/javascript')\n            for(let key in script) {\n                if(key.startsWith(\"on\")) {\n                    scriptNode[key] = script[key]\n                }\n            }\n            document.head.appendChild(scriptNode)\n            backupScripts.blacklisted.splice(index - indexOffset, 1)\n            indexOffset++\n        }\n    })\n\n    let iframeIndexOffset = 0;\n    [...backupIframes.blacklisted].forEach(([id, frame], index) => {\n        let attributes = [...frame.attributes];\n        let placeholder = document.querySelector(`span[data-yett-id=${id}]`);\n        let newIframe = document.createElement('iframe');\n        console.log(attributes);\n        attributes.forEach( attr => {\n            if(attr.name.startsWith('data-') || attr.name.startsWith('allow')) {\n                newIframe.setAttribute(attr.name, attr.value)\n            } else if (attr.name.startsWith('class')) {\n                attr.value.split(\" \").forEach( myClass => {\n                    newIframe.classList.add(myClass);\n                });;\n            } else if (attr.name.startsWith('allow')) {\n\n            } else {\n                newIframe[attr.name] = attr.value;\n            }\n        });\n\n        placeholder.parentElement.insertBefore(newIframe, placeholder);\n        placeholder.parentElement.removeChild(placeholder);\n        backupIframes.blacklisted.splice(index - iframeIndexOffset, 1)\n        iframeIndexOffset++\n    });\n\n    // Disconnect the observer if the blacklist is empty for performance reasons\n    if(patterns.blacklist && patterns.blacklist.length < 1) {\n        observer.disconnect()\n    }\n}"],"names":["isOnBlacklist","src","type","TYPE_ATTRIBUTE","patterns","blacklist","some","pattern","test","whitelist","every","willBeUnblocked","script","getAttribute","entry","window","YETT_BLACKLIST","YETT_WHITELIST","backupScripts","blacklisted","features","YETT_IFRAME","backupIframes","observer","MutationObserver","mutations","console","log","i","length","addedNodes","node","nodeType","tagName","push","addEventListener","beforeScriptExecuteListener","event","preventDefault","removeEventListener","parentElement","removeChild","id","Math","floor","random","newPlaceholder","document","createElement","setAttribute","insertBefore","observe","documentElement","childList","subtree","createElementBackup","originalDescriptors","Object","getOwnPropertyDescriptor","HTMLScriptElement","prototype","args","toLowerCase","bind","scriptElt","defineProperties","get","call","this","set","value","typeValue","name","error","warn","URL_REPLACER_REGEXP","RegExp","scriptUrlsOrRegexes","filter","urlOrRegexp","toString","map","permissiveRegexp","replace","p","Boolean","tags","querySelectorAll","indexOffset","forEach","index","scriptNode","key","startsWith","head","appendChild","splice","iframeIndexOffset","attributes","placeholder","querySelector","newIframe","attr","split","myClass","classList","add","disconnect"],"mappings":"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"}